<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CapFast Latency Analyzer</title>
  <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    h1, h2, h3 {
      color: #333;
    }
    .chart-container {
      height: 400px;
      margin-top: 20px;
    }
    .file-section {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f8f8f8;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    .analysis-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .form-group {
      margin: 5px 0;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .tooltip {
      cursor: help;
      color: #4285f4;
      font-weight: bold;
      position: relative;
      display: inline-block;
    }
    .tooltip:hover::before {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 5px 10px;
      background-color: #333;
      color: white;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 12px;
      z-index: 1000;
    }
    .progress-section {
      margin: 15px 0;
      display: none;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-fill {
      height: 100%;
      background-color: #4CAF50;
      width: 0%;
      transition: width 0.3s;
    }
    .memory-bar {
      width: 100%;
      height: 12px;
      background-color: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }
    .memory-fill {
      height: 100%;
      background-color: #2196F3;
      width: 0%;
      transition: width 0.3s;
    }
    .memory-status {
      font-size: 14px;
      color: #555;
    }
    .results-section {
      margin-top: 20px;
      display: none;
    }
    button {
      padding: 8px 12px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #3367d6;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    select, input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .file-info {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
    .log-messages {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 10px;
      padding: 10px;
      background-color: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    .log-message {
      margin: 2px 0;
      padding: 2px 0;
      border-bottom: 1px solid #eee;
    }
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background-color: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .stat-card h3 {
      margin-top: 0;
      color: #666;
      font-size: 14px;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4285f4;
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 15px;
      cursor: pointer;
      background-color: #eee;
      margin-right: 5px;
      border-top-left-radius: 3px;
      border-top-right-radius: 3px;
    }
    .tab.active {
      background-color: white;
      border: 1px solid #ddd;
      border-bottom: none;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border: 1px solid #ddd;
    }
    th {
      background-color: #f2f2f2;
    }
    .action-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .chart-options {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    .chart-options .form-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>CapFast Latency Analyzer</h1>
    
    <div class="file-section">
      <h2>Select Capture File</h2>
      <div class="button-group">
        <button id="select-file-btn">Select Capture File</button>
        <button id="load-analysis-btn">Load Previous Analysis</button>
      </div>
      <div id="file-path" class="file-info">No file selected</div>
      <div id="file-details" class="file-info"></div>
      <button id="analyze-btn" disabled>Analyze File</button>
    </div>
    
    <div id="progress-section" class="progress-section">
      <h2>Analysis Progress</h2>
      <div class="progress-bar">
        <div id="progress-fill" class="progress-fill"></div>
      </div>
      <div id="progress-text">0%</div>
      
      <div id="memory-status" class="memory-status" style="display: none; margin: 10px 0;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
          <span>Memory Usage:</span>
          <span id="memory-percentage">0%</span>
        </div>
        <div class="memory-bar">
          <div id="memory-fill" class="memory-fill"></div>
        </div>
        <div id="memory-tips" style="margin-top: 5px; font-size: 12px; color: #666; display: none;">
          <strong>Memory optimization tips:</strong>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li>Close other applications to free system memory</li>
            <li>Analyze fewer signals or focus on specific signals of interest</li>
            <li>For very large files (>5GB), expect longer processing times</li>
            <li>The application automatically adjusts batch sizes for optimal performance</li>
          </ul>
        </div>
      </div>
      
      <div class="log-messages" id="log-messages"></div>
    </div>
    
    <div id="results-section" class="results-section">
      <h2>Analysis Results</h2>
      
      <div class="summary-stats" id="summary-stats">
        <!-- Summary statistics will be inserted here -->
      </div>
      
      <div class="form-group">
        <label for="signal-select">Select Signal: </label>
        <div style="display: flex; width: 100%; max-width: 600px; gap: 8px;">
          <input type="text" id="signal-search" placeholder="Search by IP address..." style="flex-grow: 1;">
          <select id="signal-select" style="flex-grow: 2;"></select>
        </div>
      </div>
      
      <div class="tabs">
        <div class="tab active" data-tab="time-series">Time Series</div>
        <div class="tab" data-tab="distribution">Distribution</div>
        <div class="tab" data-tab="statistics">Statistics</div>
      </div>
      
      <div class="tab-content active" id="time-series-tab">
        <div class="chart-options">
          <div class="form-group">
            <label for="x-axis-format">X-Axis Time Format:</label>
            <select id="x-axis-format">
              <option value="seconds">Seconds</option>
              <option value="time-hawaii">Wall Clock (Hawaii Time)</option>
              <option value="time-utc">Wall Clock (UTC)</option>
              <option value="time-chile">Wall Clock (Chile Time)</option>
            </select>
            <span class="tooltip" title="Seconds: Time since start of capture. Wall Clock: Time of day in selected timezone.">ⓘ</span>
          </div>
          <div class="form-group">
            <label for="y-axis-scale">Y-Axis Scale:</label>
            <select id="y-axis-scale">
              <option value="ns">Nanoseconds</option>
              <option value="us">Microseconds</option>
              <option value="ms">Milliseconds</option>
            </select>
          </div>
          <div class="form-group">
            <button id="refresh-chart-btn">Refresh Chart</button>
            <button id="reset-zoom-btn">Reset Zoom</button>
            <div style="display: flex; gap: 5px; margin-left: 10px;">
              <button id="zoom-x-in-btn" title="Zoom in X axis">X+</button>
              <button id="zoom-x-out-btn" title="Zoom out X axis">X-</button>
              <button id="zoom-y-in-btn" title="Zoom in Y axis">Y+</button>
              <button id="zoom-y-out-btn" title="Zoom out Y axis">Y-</button>
            </div>
          </div>
        </div>
        
        <!-- Chart style options -->
        <div class="chart-controls" style="margin-bottom: 15px; border: 1px solid #eee; padding: 10px; border-radius: 5px; background-color: #f9f9f9;">
          <h4 style="margin: 0 0 5px 0; font-size: 14px;">Chart Style</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
            <div>
              <label for="chart-type" style="font-size: 12px;">Chart Type:</label>
              <select id="chart-type" style="padding: 4px;">
                <option value="scatter">Scatter</option>
                <option value="line">Line</option>
                <option value="bar">Bar</option>
              </select>
            </div>
            <div>
              <label for="point-style" style="font-size: 12px;">Point Style:</label>
              <select id="point-style" style="padding: 4px;">
                <option value="circle">Circle</option>
                <option value="cross">Cross</option>
                <option value="crossRot">Cross (Rotated)</option>
                <option value="dash">Dash</option>
                <option value="line">Line</option>
                <option value="rect">Rectangle</option>
                <option value="rectRounded">Rectangle (Rounded)</option>
                <option value="rectRot">Rectangle (Rotated)</option>
                <option value="star">Star</option>
                <option value="triangle">Triangle</option>
              </select>
            </div>
            <div>
              <label for="point-size" style="font-size: 12px;">Point Size:</label>
              <input type="number" id="point-size" value="3" min="1" max="10" style="width: 50px; padding: 4px;">
            </div>
            <div>
              <label for="line-thickness" style="font-size: 12px;">Line Thickness:</label>
              <input type="number" id="line-thickness" value="2" min="1" max="10" style="width: 50px; padding: 4px;">
            </div>
            <div>
              <label for="point-color" style="font-size: 12px;">Point Color:</label>
              <input type="color" id="point-color" value="#4285f4" style="width: 50px; padding: 0px;">
            </div>
            <div>
              <label for="line-color" style="font-size: 12px;">Line Color:</label>
              <input type="color" id="line-color" value="#4285f4" style="width: 50px; padding: 0px;">
            </div>
            <button id="apply-style">Apply Style</button>
          </div>
        </div>
        
        <!-- Manual zoom controls -->
        <div class="chart-controls" style="margin-bottom: 15px; border: 1px solid #eee; padding: 10px; border-radius: 5px; background-color: #f9f9f9;">
          <div style="display: flex; gap: 20px; margin-bottom: 10px;">
            <div>
              <h4 style="margin: 0 0 5px 0; font-size: 14px;">Manual Zoom</h4>
              <div style="display: flex; gap: 10px; align-items: center;">
                <div>
                  <label for="x-min" style="font-size: 12px;">X Min:</label>
                  <input type="text" id="x-min" style="width: 80px; padding: 4px;">
                </div>
                <div>
                  <label for="x-max" style="font-size: 12px;">X Max:</label>
                  <input type="text" id="x-max" style="width: 80px; padding: 4px;">
                </div>
                <div>
                  <label for="y-min" style="font-size: 12px;">Y Min:</label>
                  <input type="text" id="y-min" style="width: 80px; padding: 4px;">
                </div>
                <div>
                  <label for="y-max" style="font-size: 12px;">Y Max:</label>
                  <input type="text" id="y-max" style="width: 80px; padding: 4px;">
                </div>
                <button id="apply-manual-zoom" style="padding: 4px 8px;">Apply Zoom</button>
              </div>
            </div>
          </div>
          
          <div>
            <h4 style="margin: 0 0 5px 0; font-size: 14px;">Time Range Selector</h4>
            <div style="display: flex; gap: 10px; align-items: center;">
              <div>
                <label for="time-start" style="font-size: 12px;">Start:</label>
                <input type="text" id="time-start" placeholder="seconds or HH:MM:SS" style="width: 150px; padding: 4px;">
              </div>
              <div>
                <label for="time-end" style="font-size: 12px;">End:</label>
                <input type="text" id="time-end" placeholder="seconds or HH:MM:SS" style="width: 150px; padding: 4px;">
              </div>
              <button id="apply-time-range" style="padding: 4px 8px;">Apply Range</button>
              <button id="reset-time-range" style="padding: 4px 8px;">Reset</button>
            </div>
          </div>
        </div>
        
        <div class="chart-container">
          <canvas id="time-series-chart"></canvas>
        </div>
      </div>
      
      <div class="tab-content" id="distribution-tab">
        <div class="chart-options">
          <div class="form-group">
            <button id="reset-dist-zoom-btn">Reset Zoom</button>
            <div style="display: flex; gap: 5px; margin-left: 10px;">
              <button id="dist-zoom-x-in-btn" title="Zoom in X axis">X+</button>
              <button id="dist-zoom-x-out-btn" title="Zoom out X axis">X-</button>
              <button id="dist-zoom-y-in-btn" title="Zoom in Y axis">Y+</button>
              <button id="dist-zoom-y-out-btn" title="Zoom out Y axis">Y-</button>
            </div>
          </div>
        </div>
        
        <!-- Manual zoom controls for distribution chart -->
        <div class="chart-controls" style="margin-bottom: 15px; border: 1px solid #eee; padding: 10px; border-radius: 5px; background-color: #f9f9f9;">
          <div>
            <h4 style="margin: 0 0 5px 0; font-size: 14px;">Manual Zoom</h4>
            <div style="display: flex; gap: 10px; align-items: center;">
              <div>
                <label for="dist-x-min" style="font-size: 12px;">X Min:</label>
                <input type="text" id="dist-x-min" style="width: 80px; padding: 4px;">
              </div>
              <div>
                <label for="dist-x-max" style="font-size: 12px;">X Max:</label>
                <input type="text" id="dist-x-max" style="width: 80px; padding: 4px;">
              </div>
              <div>
                <label for="dist-y-min" style="font-size: 12px;">Y Min:</label>
                <input type="text" id="dist-y-min" style="width: 80px; padding: 4px;">
              </div>
              <div>
                <label for="dist-y-max" style="font-size: 12px;">Y Max:</label>
                <input type="text" id="dist-y-max" style="width: 80px; padding: 4px;">
              </div>
              <button id="apply-dist-manual-zoom" style="padding: 4px 8px;">Apply Zoom</button>
            </div>
          </div>
        </div>
        
        <div class="chart-container">
          <canvas id="distribution-chart"></canvas>
        </div>
      </div>
      
      <div class="tab-content" id="statistics-tab">
        <table id="stats-table">
          <thead>
            <tr>
              <th>Metric</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <!-- Statistics will be inserted here -->
          </tbody>
        </table>
      </div>
      
      <div class="action-buttons">
        <button id="save-analysis-btn">Save Analysis Results</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    
    // Set Hawaii timezone offset in hours
    const HAWAII_TIMEZONE_OFFSET = -10;
    
    // Ensure moment adapter is properly registered for Chart.js
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Initializing CapFast Latency Analyzer');
      
      // Check if moment adapter is available
      if (typeof Chart !== 'undefined' && Chart.register) {
        console.log('Chart.js is available');
      } else {
        console.error('Chart.js is not properly loaded');
      }
    });
    
    // DOM elements
    const selectFileBtn = document.getElementById('select-file-btn');
    const loadAnalysisBtn = document.getElementById('load-analysis-btn');
    const analyzeBtn = document.getElementById('analyze-btn');
    const saveAnalysisBtn = document.getElementById('save-analysis-btn');
    const filePathElement = document.getElementById('file-path');
    const fileDetailsElement = document.getElementById('file-details');
    const progressSection = document.getElementById('progress-section');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const logMessages = document.getElementById('log-messages');
    const resultsSection = document.getElementById('results-section');
    const summaryStatsContainer = document.getElementById('summary-stats');
    const signalSelect = document.getElementById('signal-select');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const memoryStatus = document.getElementById('memory-status');
    const memoryFill = document.getElementById('memory-fill');
    const memoryPercentage = document.getElementById('memory-percentage');
    
    // Global variables
    let selectedFilePath = null;
    let analysisResults = null;
    let timeSeriesChart = null;
    let distributionChart = null;
    
    // Handle file selection
    selectFileBtn.addEventListener('click', async () => {
      const filePath = await ipcRenderer.invoke('select-file');
      
      if (filePath) {
        selectedFilePath = filePath;
        filePathElement.textContent = filePath;
        
        // Get file stats
        const stats = await ipcRenderer.invoke('get-file-stats', filePath);
        if (stats) {
          fileDetailsElement.textContent = `Size: ${formatFileSize(stats.size)}`;
        }
        
        // Enable analyze button
        analyzeBtn.disabled = false;
      }
    });
    
    // Handle loading previous analysis
    loadAnalysisBtn.addEventListener('click', async () => {
      const filePath = await ipcRenderer.invoke('show-load-dialog');
      
      if (filePath) {
        resetUI();
        progressSection.style.display = 'block';
        addLogMessage(`Loading analysis from ${filePath}...`);
        
        try {
          analysisResults = await ipcRenderer.invoke('load-analysis', filePath);
          
          if (analysisResults.error) {
            addLogMessage(`Error: ${analysisResults.error}`);
          } else {
            // Update file info if available
            if (analysisResults._fileInfo) {
              filePathElement.textContent = analysisResults._fileInfo.path || 'Original file path not available';
              fileDetailsElement.textContent = `Size: ${formatFileSize(analysisResults._fileInfo.size || 0)}`;
              addLogMessage(`Analysis date: ${new Date(analysisResults._fileInfo.date).toLocaleString()}`);
            }
            
            // Display results
            displayResults(analysisResults);
            addLogMessage('Analysis loaded successfully');
          }
        } catch (error) {
          addLogMessage(`Error loading file: ${error.message}`);
        }
      }
    });
    
    // Handle analysis button click
    analyzeBtn.addEventListener('click', async () => {
      if (!selectedFilePath) return;
      
      // Reset UI
      resetUI();
      
      // Show progress section
      progressSection.style.display = 'block';
      
      // Log start message
      addLogMessage('Starting analysis...');
      
      try {
        // Start analysis
        analysisResults = await ipcRenderer.invoke('analyze-file', selectedFilePath);
        
        if (analysisResults.error) {
          addLogMessage(`Error: ${analysisResults.error}`);
          if (analysisResults.details) {
            addLogMessage(`Details: ${analysisResults.details}`);
          }
        } else {
          // Display results
          displayResults(analysisResults);
        }
      } catch (error) {
        addLogMessage(`Error: ${error.message}`);
      }
    });
    
    // Handle saving analysis
    saveAnalysisBtn.addEventListener('click', async () => {
      if (!analysisResults) {
        addLogMessage('No analysis results to save');
        return;
      }
      
      const savePath = await ipcRenderer.invoke('show-save-dialog');
      if (savePath) {
        addLogMessage(`Saving analysis to ${savePath}...`);
        
        try {
          const result = await ipcRenderer.invoke('save-analysis', analysisResults, savePath);
          
          if (result.success) {
            addLogMessage(`Analysis saved successfully to ${savePath}`);
          } else {
            addLogMessage(`Error saving analysis: ${result.error}`);
          }
        } catch (error) {
          addLogMessage(`Error saving file: ${error.message}`);
        }
      }
    });
    
    // Listen for analysis status updates
    ipcRenderer.on('analysis-status', (event, status) => {
      updateProgress(status);
    });
    
    // Handle tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Update active tab
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show selected tab content
        const tabId = tab.getAttribute('data-tab');
        tabContents.forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabId + '-tab').classList.add('active');
      });
    });
    
    // Handle signal selection change
    signalSelect.addEventListener('change', () => {
      updateCharts();
    });
    
    // Handle signal search
    const signalSearch = document.getElementById('signal-search');
    signalSearch.addEventListener('input', () => {
      const searchTerm = signalSearch.value.toLowerCase();
      
      // Get all options
      const options = Array.from(signalSelect.options);
      let matchFound = false;
      
      // For each option
      options.forEach(option => {
        // Get the text and check if it contains the search term
        const text = option.text.toLowerCase();
        const matches = text.includes(searchTerm);
        
        // Show/hide option based on match
        option.style.display = matches ? '' : 'none';
        
        // Track if we found any matches
        if (matches && !matchFound) {
          matchFound = true;
          // Select first match
          option.selected = true;
        }
      });
      
      // If search term is not empty and we found matches, update charts
      if (searchTerm && matchFound) {
        updateCharts();
      }
    });
    
    // Initialize the manual zoom and time range inputs
    function updateZoomInputs() {
      if (timeSeriesChart) {
        const xAxis = timeSeriesChart.scales.x;
        const yAxis = timeSeriesChart.scales.y;
        
        document.getElementById('x-min').value = xAxis.min !== undefined ? formatAxisValue(xAxis.min, 'x') : '';
        document.getElementById('x-max').value = xAxis.max !== undefined ? formatAxisValue(xAxis.max, 'x') : '';
        document.getElementById('y-min').value = yAxis.min !== undefined ? formatAxisValue(yAxis.min, 'y') : '';
        document.getElementById('y-max').value = yAxis.max !== undefined ? formatAxisValue(yAxis.max, 'y') : '';
      }
    }
    
    // Format axis values depending on the axis and current options
    function formatAxisValue(value, axis) {
      if (axis === 'x') {
        const xAxisFormat = document.getElementById('x-axis-format').value;
        if (xAxisFormat.startsWith('time-')) {
          // Format as time
          const date = new Date(value);
          return date.toISOString().substr(11, 8); // Extract HH:MM:SS
        } else {
          // Format as seconds
          return value.toFixed(3);
        }
      } else {
        // Format Y axis based on scale
        const yAxisScale = document.getElementById('y-axis-scale').value;
        const precision = yAxisScale === 'ns' ? 0 : (yAxisScale === 'us' ? 2 : 3);
        return value.toFixed(precision);
      }
    }
    
    // Parse axis value based on axis type
    function parseAxisValue(value, axis) {
      if (axis === 'x') {
        const xAxisFormat = document.getElementById('x-axis-format').value;
        if (xAxisFormat.startsWith('time-')) {
          // Parse time format (HH:MM:SS)
          if (value.includes(':')) {
            const [hours, minutes, seconds] = value.split(':').map(Number);
            const date = new Date();
            // Set current date but the provided time
            date.setHours(hours || 0, minutes || 0, seconds || 0, 0);
            
            // For time modes, we need to return the millisecond timestamp
            return date.getTime();
          }
        }
        // Default to parsing as float (seconds)
        return parseFloat(value);
      } else {
        // Parse Y value as float
        return parseFloat(value);
      }
    }
    
    // Apply manual zoom when the Apply button is clicked
    document.getElementById('apply-manual-zoom').addEventListener('click', () => {
      if (!timeSeriesChart) return;
      
      const xMin = document.getElementById('x-min').value;
      const xMax = document.getElementById('x-max').value;
      const yMin = document.getElementById('y-min').value;
      const yMax = document.getElementById('y-max').value;
      
      // Update the chart's scales
      const options = timeSeriesChart.options;
      const xAxisFormat = document.getElementById('x-axis-format').value;
      
      if (xMin && xMax) {
        // For time format, we need to convert time strings to date objects
        if (xAxisFormat.startsWith('time-')) {
          console.log(`Parsing time range: ${xMin} to ${xMax}`);
          options.scales.x.min = parseAxisValue(xMin, 'x');
          options.scales.x.max = parseAxisValue(xMax, 'x');
          console.log(`Parsed to timestamps: ${options.scales.x.min} to ${options.scales.x.max}`);
        } else {
          options.scales.x.min = parseAxisValue(xMin, 'x');
          options.scales.x.max = parseAxisValue(xMax, 'x');
        }
      }
      
      if (yMin && yMax) {
        options.scales.y.min = parseAxisValue(yMin, 'y');
        options.scales.y.max = parseAxisValue(yMax, 'y');
      }
      
      timeSeriesChart.update();
    });
    
    // Update input fields when chart is zoomed
    function onChartZoom() {
      updateZoomInputs();
    }
    
    // Time range selection
    let originalTimeSeriesData = null;
    
    document.getElementById('apply-time-range').addEventListener('click', () => {
      if (!timeSeriesChart) return;
      
      const startValue = document.getElementById('time-start').value;
      const endValue = document.getElementById('time-end').value;
      
      if (!startValue || !endValue) {
        alert('Please enter both start and end time values');
        return;
      }
      
      // Store original data if not already stored
      if (!originalTimeSeriesData) {
        originalTimeSeriesData = [...timeSeriesChart.data.datasets[0].data];
      }
      
      // Parse start and end times
      const xAxisFormat = document.getElementById('x-axis-format').value;
      let startTime, endTime;
      
      if (xAxisFormat.startsWith('time-')) {
        // Parse as time strings (HH:MM:SS)
        if (startValue.includes(':') && endValue.includes(':')) {
          const [startHours, startMinutes, startSeconds] = startValue.split(':').map(Number);
          const [endHours, endMinutes, endSeconds] = endValue.split(':').map(Number);
          
          const startDate = new Date();
          startDate.setHours(startHours, startMinutes, startSeconds, 0);
          
          const endDate = new Date();
          endDate.setHours(endHours, endMinutes, endSeconds, 0);
          
          startTime = startDate.getTime();
          endTime = endDate.getTime();
        } else {
          alert('For time format, please enter time as HH:MM:SS');
          return;
        }
      } else {
        // Parse as seconds
        startTime = parseFloat(startValue);
        endTime = parseFloat(endValue);
      }
      
      // Filter data based on time range
      const filteredData = originalTimeSeriesData.filter(point => {
        return point.x >= startTime && point.x <= endTime;
      });
      
      // Update chart with filtered data
      timeSeriesChart.data.datasets[0].data = filteredData;
      timeSeriesChart.update();
      
      console.log(`Applied time range filter: ${startTime} to ${endTime}, showing ${filteredData.length} points`);
    });
    
    // Reset time range filter
    document.getElementById('reset-time-range').addEventListener('click', () => {
      if (!timeSeriesChart || !originalTimeSeriesData) return;
      
      // Restore original data
      timeSeriesChart.data.datasets[0].data = originalTimeSeriesData;
      timeSeriesChart.update();
      
      // Clear input fields
      document.getElementById('time-start').value = '';
      document.getElementById('time-end').value = '';
      
      console.log('Reset time range filter');
    });
    
    // Handle x-axis format change
    document.getElementById('x-axis-format').addEventListener('change', () => {
      updateCharts();
    });
    
    // Handle y-axis scale change
    document.getElementById('y-axis-scale').addEventListener('change', () => {
      updateCharts();
    });
    
    // Axis specific zoom for time series chart
    document.getElementById('zoom-x-in-btn').addEventListener('click', () => {
      if (timeSeriesChart) {
        timeSeriesChart.zoom(1.2, 1, 'x');
      }
    });
    
    document.getElementById('zoom-x-out-btn').addEventListener('click', () => {
      if (timeSeriesChart) {
        timeSeriesChart.zoom(0.8, 1, 'x');
      }
    });
    
    document.getElementById('zoom-y-in-btn').addEventListener('click', () => {
      if (timeSeriesChart) {
        // Use scales directly for Y-axis zooming since the chart zoom method isn't working properly
        const yAxis = timeSeriesChart.scales.y;
        const currentRange = yAxis.max - yAxis.min;
        const center = (yAxis.max + yAxis.min) / 2;
        const newRange = currentRange / 1.2; // Reduce range by 20%
        
        // Set new min and max
        timeSeriesChart.options.scales.y.min = center - (newRange / 2);
        timeSeriesChart.options.scales.y.max = center + (newRange / 2);
        timeSeriesChart.update();
        
        // Update manual zoom inputs
        updateZoomInputs();
      }
    });
    
    document.getElementById('zoom-y-out-btn').addEventListener('click', () => {
      if (timeSeriesChart) {
        // Use scales directly for Y-axis zooming since the chart zoom method isn't working properly
        const yAxis = timeSeriesChart.scales.y;
        const currentRange = yAxis.max - yAxis.min;
        const center = (yAxis.max + yAxis.min) / 2;
        const newRange = currentRange * 1.2; // Increase range by 20%
        
        // Set new min and max
        timeSeriesChart.options.scales.y.min = center - (newRange / 2);
        timeSeriesChart.options.scales.y.max = center + (newRange / 2);
        timeSeriesChart.update();
        
        // Update manual zoom inputs
        updateZoomInputs();
      }
    });
    
    // Axis specific zoom for distribution chart
    document.getElementById('dist-zoom-x-in-btn').addEventListener('click', () => {
      if (distributionChart) {
        distributionChart.zoom(1.2, 1, 'x');
      }
    });
    
    document.getElementById('dist-zoom-x-out-btn').addEventListener('click', () => {
      if (distributionChart) {
        distributionChart.zoom(0.8, 1, 'x');
      }
    });
    
    document.getElementById('dist-zoom-y-in-btn').addEventListener('click', () => {
      if (distributionChart) {
        // Use scales directly for Y-axis zooming
        const yAxis = distributionChart.scales.y;
        const currentRange = yAxis.max - yAxis.min;
        const center = (yAxis.max + yAxis.min) / 2;
        const newRange = currentRange / 1.2; // Reduce range by 20%
        
        // Set new min and max
        distributionChart.options.scales.y.min = center - (newRange / 2);
        distributionChart.options.scales.y.max = center + (newRange / 2);
        distributionChart.update();
        
        // Update manual zoom inputs
        updateDistZoomInputs();
      }
    });
    
    document.getElementById('dist-zoom-y-out-btn').addEventListener('click', () => {
      if (distributionChart) {
        // Use scales directly for Y-axis zooming
        const yAxis = distributionChart.scales.y;
        const currentRange = yAxis.max - yAxis.min;
        const center = (yAxis.max + yAxis.min) / 2;
        const newRange = currentRange * 1.2; // Increase range by 20%
        
        // Set new min and max
        distributionChart.options.scales.y.min = center - (newRange / 2);
        distributionChart.options.scales.y.max = center + (newRange / 2);
        distributionChart.update();
        
        // Update manual zoom inputs
        updateDistZoomInputs();
      }
    });
    
    // Handle refresh chart button click
    document.getElementById('refresh-chart-btn').addEventListener('click', () => {
      console.log('Refreshing chart...');
      
      // Get current settings
      const selectedSignal = signalSelect.value;
      const xAxisFormat = document.getElementById('x-axis-format').value;
      const yAxisScale = document.getElementById('y-axis-scale').value;
      
      console.log(`Settings: signal=${selectedSignal}, xFormat=${xAxisFormat}, yScale=${yAxisScale}`);
      
      // Force destroy the chart first
      if (timeSeriesChart) {
        console.log('Destroying time series chart');
        timeSeriesChart.destroy();
        timeSeriesChart = null;
      }
      
      if (distributionChart) {
        console.log('Destroying distribution chart');
        distributionChart.destroy();
        distributionChart = null;
      }
      
      // Create a small delay to ensure DOM updates
      setTimeout(() => {
        console.log('Recreating charts after timeout');
        
        // Get the contexts fresh (in case they were affected by the destroy)
        const timeCtx = document.getElementById('time-series-chart').getContext('2d');
        const distCtx = document.getElementById('distribution-chart').getContext('2d');
        
        if (!timeCtx || !distCtx) {
          console.error('Failed to get chart contexts');
          return;
        }
        
        updateCharts();
      }, 100);
    });
    
    // Handle reset zoom button click
    document.getElementById('reset-zoom-btn').addEventListener('click', () => {
      console.log('Resetting zoom for time series chart');
      
      // Reset zoom on time series chart
      if (timeSeriesChart) {
        timeSeriesChart.resetZoom();
      }
    });
    
    // Handle reset zoom button click for distribution chart
    document.getElementById('reset-dist-zoom-btn').addEventListener('click', () => {
      console.log('Resetting zoom for distribution chart');
      
      // Reset zoom on distribution chart
      if (distributionChart) {
        distributionChart.resetZoom();
      }
    });
    
    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(1024));
      
      return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
    }
    
    // Reset UI for new analysis
    function resetUI() {
      // Clear log messages
      logMessages.innerHTML = '';
      
      // Reset progress bar
      progressFill.style.width = '0%';
      progressText.textContent = '0%';
      
      // Hide results section
      resultsSection.style.display = 'none';
      
      // Clear previous charts
      if (timeSeriesChart) {
        timeSeriesChart.destroy();
        timeSeriesChart = null;
      }
      
      if (distributionChart) {
        distributionChart.destroy();
        distributionChart = null;
      }
    }
    
    // Update progress bar and status
    function updateProgress(status) {
      // Update progress bar
      progressFill.style.width = `${status.progress}%`;
      progressText.textContent = `${status.progress}%`;
      
      // Add log message
      addLogMessage(status.message);
      
      // Add memory usage info if available
      if (status.memory) {
        addLogMessage(`Memory usage - Heap: ${status.memory.heap}, System: ${status.memory.system}`);
        
        // Show memory status bar
        memoryStatus.style.display = 'block';
        
        // Extract percentage value
        const heapPercent = parseFloat(status.memory.heap);
        memoryFill.style.width = `${heapPercent}%`;
        memoryPercentage.textContent = status.memory.heap;
        
        // Color based on usage
        if (heapPercent > 80) {
          memoryFill.style.backgroundColor = '#f44336'; // Red
          document.getElementById('memory-tips').style.display = 'block'; // Show memory tips
        } else if (heapPercent > 60) {
          memoryFill.style.backgroundColor = '#FF9800'; // Orange
          document.getElementById('memory-tips').style.display = 'block'; // Show memory tips
        } else {
          memoryFill.style.backgroundColor = '#2196F3'; // Blue
          document.getElementById('memory-tips').style.display = 'none'; // Hide memory tips
        }
      }
      
      // Show results when complete
      if (status.status === 'complete') {
        progressFill.style.backgroundColor = '#4CAF50'; // Green
      } else if (status.status === 'error') {
        progressFill.style.backgroundColor = '#f44336'; // Red
      } else if (status.status === 'memory-emergency') {
        // Show warning for emergency memory management
        progressFill.style.backgroundColor = '#FFC107'; // Amber/warning
        addLogMessage('⚠️ Memory management activated: Some data points were automatically reduced to prevent memory overflow');
        document.getElementById('memory-tips').style.display = 'block'; // Show memory tips
      }
    }
    
    // Add log message
    function addLogMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'log-message';
      messageElement.textContent = message;
      logMessages.appendChild(messageElement);
      logMessages.scrollTop = logMessages.scrollHeight;
    }
    
    // Display analysis results
    function displayResults(results) {
      // Show results section
      resultsSection.style.display = 'block';
      
      // Clear previous UI
      summaryStatsContainer.innerHTML = '';
      signalSelect.innerHTML = '';
      
      // Get signals and sort by average latency (exclude internal _fileInfo key)
      const signals = Object.keys(results)
        .filter(key => key !== '_fileInfo')
        .sort((a, b) => results[b].stats.avgLatency - results[a].stats.avgLatency);
      
      if (signals.length === 0) {
        addLogMessage('No signals found with sufficient data points.');
        return;
      }
      
      // Populate signal selector
      signals.forEach(signalId => {
        const option = document.createElement('option');
        option.value = signalId;
        option.textContent = `${signalId} (${results[signalId].stats.count} samples)`;
        signalSelect.appendChild(option);
      });
      
      // Calculate summary statistics
      const totalSignals = signals.length;
      const totalSamples = signals.reduce((sum, signal) => sum + results[signal].stats.count, 0);
      const overallAvgLatency = signals.reduce((sum, signal) => 
        sum + results[signal].stats.avgLatency, 0) / totalSignals;
      const maxLatency = Math.max(...signals.map(s => results[s].stats.maxLatency));
      
      // Add summary statistic cards
      const summaryStats = [
        { label: 'Total Signals', value: totalSignals },
        { label: 'Total Samples', value: totalSamples.toLocaleString() },
        { label: 'Avg Latency', value: overallAvgLatency.toFixed(2) + ' µs' },
        { label: 'Max Latency', value: maxLatency.toFixed(2) + ' µs' }
      ];
      
      summaryStats.forEach(stat => {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.innerHTML = `
          <h3>${stat.label}</h3>
          <div class="stat-value">${stat.value}</div>
        `;
        summaryStatsContainer.appendChild(card);
      });
      
      // Update charts with first signal
      updateCharts();
    }
    
    // Update charts based on selected signal
    function updateCharts() {
      if (!analysisResults) return;
      
      const selectedSignal = signalSelect.value;
      if (!selectedSignal) return;
      
      const signalData = analysisResults[selectedSignal];
      
      // Get time format and scale options
      const xAxisFormat = document.getElementById('x-axis-format').value;
      const yAxisScale = document.getElementById('y-axis-scale').value;
      
      // Update time series chart
      updateTimeSeriesChart(signalData, xAxisFormat, yAxisScale);
      
      // Update distribution chart
      updateDistributionChart(signalData, yAxisScale);
      
      // Update statistics table
      updateStatisticsTable(signalData, yAxisScale);
    }
    
    // Scale latency value based on selected scale
    function scaleLatency(latency, scale) {
      switch (scale) {
        case 'ns':
          return latency * 1000; // Convert μs to ns
        case 'us':
          return latency; // No scaling (already in μs)
        case 'ms':
          return latency / 1000; // Convert μs to ms
        default:
          return latency;
      }
    }
    
    // Get y-axis label based on scale
    function getYAxisLabel(scale) {
      switch (scale) {
        case 'ns':
          return 'Latency (ns)';
        case 'us':
          return 'Latency (μs)';
        case 'ms':
          return 'Latency (ms)';
        default:
          return 'Latency';
      }
    }
    
    // Update time series chart with new data
    function updateTimeSeriesChart(signalData, xAxisFormat, yAxisScale) {
      const ctx = document.getElementById('time-series-chart').getContext('2d');
      
      // Destroy previous chart if it exists
      if (timeSeriesChart) {
        timeSeriesChart.destroy();
      }
      
      // Create different datasets based on xAxisFormat
      let datasets = [];
      let chartType = document.getElementById('chart-type')?.value || 'scatter';
      let xAxisType = 'linear';
      let xAxisLabel = 'Time (seconds)';
      
      console.log(`Total data points: ${signalData.sampleData.length}`);
      
      // Get style settings if available
      const pointStyle = document.getElementById('point-style')?.value || 'circle';
      const pointSize = parseInt(document.getElementById('point-size')?.value || '3');
      const lineThickness = parseInt(document.getElementById('line-thickness')?.value || '2');
      const pointColor = document.getElementById('point-color')?.value || 'rgba(66, 133, 244, 0.7)';
      const lineColor = document.getElementById('line-color')?.value || 'rgba(66, 133, 244, 1)';
      
      // Performance optimization for extremely large datasets
      let pointData;
      const MAX_RENDER_POINTS = 25000; // Maximum points to render initially
      
      if (signalData.sampleData.length > MAX_RENDER_POINTS) {
        console.log(`Dataset too large (${signalData.sampleData.length} points), using decimation for initial view`);
        const decimationFactor = Math.ceil(signalData.sampleData.length / MAX_RENDER_POINTS);
        pointData = [];
        
        // Use decimation to show a representative sample initially
        for (let i = 0; i < signalData.sampleData.length; i += decimationFactor) {
          const point = signalData.sampleData[i];
          if (xAxisFormat === 'seconds') {
            pointData.push({
              x: point.timestamp,
              y: scaleLatency(point.latency, yAxisScale)
            });
          } else {
            pointData.push({
              x: new Date(point.timestamp * 1000),
              y: scaleLatency(point.latency, yAxisScale)
            });
          }
        }
        
        addLogMessage(`Performance mode: Initially rendering ${pointData.length} of ${signalData.sampleData.length} points. Zoom in to see more detail.`);
        
      } else if (xAxisFormat === 'seconds') {
        // For seconds format, use raw timestamps on a linear scale
        pointData = signalData.sampleData.map(point => ({
          x: point.timestamp,
          y: scaleLatency(point.latency, yAxisScale)
        }));
        
      } else if (xAxisFormat.startsWith('time')) {
        // For wall clock, use date objects
        pointData = signalData.sampleData.map(point => {
          const date = new Date(point.timestamp * 1000);
          return {
            x: date,
            y: scaleLatency(point.latency, yAxisScale)
          };
        });
      }
      
      // Calculate appropriate Y-axis range based on actual data
      const yAxisRange = calculateYAxisRange(pointData);
      
      datasets = [{
        label: 'Latency',
        data: pointData,
        backgroundColor: pointColor,
        borderColor: lineColor,
        pointRadius: pointData.length > 5000 ? Math.min(pointSize, 2) : pointSize,
        pointHoverRadius: pointSize + 2,
        borderWidth: lineThickness,
        pointStyle: pointStyle,
        showLine: chartType === 'line',
        fill: false
      }];
      
      if (xAxisFormat.startsWith('time')) {
        xAxisType = 'time';
        xAxisLabel = 'Time (' + xAxisFormat.replace('time-', '') + ')';
      }
      
      // Log chart info (limited)
      console.log(`Creating chart with format: ${xAxisFormat}, type: ${chartType}, axis: ${xAxisType}`);
      console.log(`Dataset has ${datasets[0]?.data?.length || 0} points`);
      
      // Create chart configuration
      const config = {
        type: chartType,
        data: {
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: pointData.length > 5000 ? 0 : 1000 // Disable animation for large datasets
          },
          elements: {
            point: {
              radius: pointData.length > 5000 ? Math.min(pointSize, 2) : pointSize
            },
            line: {
              tension: 0.1 // Slight curve for better visualization
            }
          },
          scales: {
            x: {
              type: xAxisType,
              title: {
                display: true,
                text: xAxisLabel
              },
              adapters: {
                date: {
                  timezone: xAxisFormat === 'time-hawaii' ? 'Pacific/Honolulu' : 
                           xAxisFormat === 'time-chile' ? 'America/Santiago' : 
                           'UTC'
                }
              },
              time: xAxisType === 'time' ? {
                unit: 'minute',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm',
                  hour: 'HH:mm'
                },
                tooltipFormat: 'HH:mm:ss.SSS'
              } : undefined,
              ticks: {
                // Ensure time ticks display properly
                callback: function(value, index, values) {
                  if (xAxisType === 'time') {
                    const date = new Date(value);
                    // Format depends on the zoom level/tick density
                    const format = values.length > 10 ? 'HH:mm:ss' : 'HH:mm:ss.SSS';
                    return new Date(value).toLocaleTimeString();
                  }
                  return value;
                }
              }
            },
            y: {
              title: {
                display: true,
                text: getYAxisLabel(yAxisScale)
              },
              beginAtZero: false,
              suggestedMin: yAxisRange.min,
              suggestedMax: yAxisRange.max
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const point = context.raw;
                  const yLabel = point.y.toFixed(2);
                  
                  if (xAxisFormat === 'time-hawaii') {
                    const localTimeStr = new Date(point.x).toLocaleTimeString('en-US', { 
                      hour12: false,
                      timeZone: 'Pacific/Honolulu'
                    });
                    return `Time: ${localTimeStr}, Latency: ${yLabel}`;
                  } else if (xAxisFormat === 'time-utc') {
                    const localTimeStr = new Date(point.x).toLocaleTimeString('en-US', { 
                      hour12: false,
                      timeZone: 'UTC'
                    });
                    return `Time: ${localTimeStr}, Latency: ${yLabel}`;
                  } else if (xAxisFormat === 'time-chile') {
                    const localTimeStr = new Date(point.x).toLocaleTimeString('en-US', { 
                      hour12: false,
                      timeZone: 'America/Santiago'
                    });
                    return `Time: ${localTimeStr}, Latency: ${yLabel}`;
                  } else {
                    return `Time: ${point.x.toFixed(3)}s, Latency: ${yLabel}`;
                  }
                }
              }
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'xy',
                modifierKey: null // Allow panning without holding any modifier key
              },
              zoom: {
                wheel: {
                  enabled: true,
                  speed: 0.1, // Slower zoom speed for better control
                },
                pinch: {
                  enabled: true
                },
                mode: 'xy',
                drag: {
                  enabled: false // Disable drag-to-zoom
                },
                sensitivity: 3, // Lower sensitivity for better control
                onZoom: function() {
                  // This will load more detailed data when zoomed in - using existing datasets
                  const chart = this.chart;
                  // Performance check
                  console.log('Zoom event detected');
                  // Update manual zoom inputs to match current zoom state
                  updateZoomInputs();
                }
              }
            }
          }
        }
      };
      
      // Create new chart
      timeSeriesChart = new Chart(ctx, config);
      
      // Initialize manual zoom input fields
      updateZoomInputs();
    }
    
    // Update distribution chart with new data
    function updateDistributionChart(signalData, yAxisScale) {
      const ctx = document.getElementById('distribution-chart').getContext('2d');
      
      // Destroy previous chart if it exists
      if (distributionChart) {
        distributionChart.destroy();
      }
      
      // Extract histogram data
      const bins = signalData.histogram.bins.map(bin => scaleLatency(bin, yAxisScale));
      const counts = signalData.histogram.counts;
      
      // Format bin labels with proper precision based on scale
      const precision = yAxisScale === 'ns' ? 0 : (yAxisScale === 'us' ? 2 : 3);
      const formattedLabels = bins.map(bin => bin.toFixed(precision));
      
      // Find min and max bin values for better X-axis display
      const minBin = Math.min(...bins);
      const maxBin = Math.max(...bins);
      console.log(`Histogram bin range: ${minBin.toFixed(precision)} to ${maxBin.toFixed(precision)} ${getUnitLabel(yAxisScale)}`);
      
      // Find max count for Y-axis scaling
      const maxCount = Math.max(...counts);
      const yMax = maxCount * 1.15; // Add 15% padding
      
      // Create chart configuration
      const config = {
        type: 'bar',
        data: {
          labels: formattedLabels,
          datasets: [{
            label: 'Frequency',
            data: counts,
            backgroundColor: 'rgba(66, 133, 244, 0.7)',
            borderColor: 'rgba(66, 133, 244, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: getYAxisLabel(yAxisScale)
              },
              ticks: {
                callback: function(value, index) {
                  // Only show a subset of labels for readability
                  return index % Math.ceil(bins.length / 20) === 0 ? formattedLabels[index] : '';
                }
              },
              min: minBin,
              max: maxBin
            },
            y: {
              title: {
                display: true,
                text: 'Frequency'
              },
              beginAtZero: true,
              suggestedMax: yMax
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  // Get the bin value from our formatted labels
                  return `${formattedLabels[context[0].dataIndex]} ${getUnitLabel(yAxisScale)}`;
                }
              }
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'xy',
                modifierKey: null // Allow panning without holding any modifier key
              },
              zoom: {
                wheel: {
                  enabled: true,
                  speed: 0.1, // Slower zoom speed for better control
                },
                pinch: {
                  enabled: true
                },
                mode: 'xy',
                drag: {
                  enabled: false // Disable drag-to-zoom
                },
                sensitivity: 3, // Lower sensitivity for better control
                onZoom: function() {
                  // Update manual zoom inputs to match current zoom state
                  updateDistZoomInputs();
                }
              }
            }
          }
        }
      };
      
      // Create new chart
      distributionChart = new Chart(ctx, config);
      
      // Initialize manual zoom input fields
      updateDistZoomInputs();
    }
    
    // Update distribution zoom input fields
    function updateDistZoomInputs() {
      if (distributionChart) {
        const xAxis = distributionChart.scales.x;
        const yAxis = distributionChart.scales.y;
        
        document.getElementById('dist-x-min').value = xAxis.min !== undefined ? xAxis.min.toFixed(3) : '';
        document.getElementById('dist-x-max').value = xAxis.max !== undefined ? xAxis.max.toFixed(3) : '';
        document.getElementById('dist-y-min').value = yAxis.min !== undefined ? yAxis.min.toFixed(0) : '';
        document.getElementById('dist-y-max').value = yAxis.max !== undefined ? yAxis.max.toFixed(0) : '';
      }
    }
    
    // Apply manual zoom for distribution chart
    document.getElementById('apply-dist-manual-zoom').addEventListener('click', () => {
      if (!distributionChart) return;
      
      const xMin = document.getElementById('dist-x-min').value;
      const xMax = document.getElementById('dist-x-max').value;
      const yMin = document.getElementById('dist-y-min').value;
      const yMax = document.getElementById('dist-y-max').value;
      
      // Update the chart's scales
      const options = distributionChart.options;
      
      if (xMin && xMax) {
        options.scales.x.min = parseFloat(xMin);
        options.scales.x.max = parseFloat(xMax);
      }
      
      if (yMin && yMax) {
        options.scales.y.min = parseFloat(yMin);
        options.scales.y.max = parseFloat(yMax);
      }
      
      distributionChart.update();
    });
    
    // Update statistics table
    function updateStatisticsTable(signalData, yAxisScale) {
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '';
      
      const stats = signalData.stats;
      const scale = document.getElementById('y-axis-scale').value;
      
      // Create rows for each statistic with scaled values
      const rows = [
        { name: 'Count', value: stats.count.toLocaleString() },
        { name: 'Average Latency', value: `${scaleLatency(stats.avgLatency, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Minimum Latency', value: `${scaleLatency(stats.minLatency, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Maximum Latency', value: `${scaleLatency(stats.maxLatency, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Standard Deviation', value: `${scaleLatency(stats.stdDev, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Jitter', value: `${stats.jitter.toFixed(4)} seconds` }
      ];
      
      // Add rows to table
      rows.forEach(row => {
        const tr = document.createElement('tr');
        
        const nameTd = document.createElement('td');
        nameTd.textContent = row.name;
        tr.appendChild(nameTd);
        
        const valueTd = document.createElement('td');
        valueTd.textContent = row.value;
        tr.appendChild(valueTd);
        
        statsTable.appendChild(tr);
      });
    }
    
    // Get unit label for statistics
    function getUnitLabel(scale) {
      switch (scale) {
        case 'ns':
          return 'nanoseconds';
        case 'us':
          return 'microseconds';
        case 'ms':
          return 'milliseconds';
        default:
          return 'units';
      }
    }
    
    // Apply chart style
    document.getElementById('apply-style').addEventListener('click', () => {
      if (!timeSeriesChart) return;
      
      // Get style settings
      const chartType = document.getElementById('chart-type').value;
      const pointStyle = document.getElementById('point-style').value;
      const pointSize = parseInt(document.getElementById('point-size').value);
      const lineThickness = parseInt(document.getElementById('line-thickness').value);
      const pointColor = document.getElementById('point-color').value;
      const lineColor = document.getElementById('line-color').value;
      
      // Update chart configuration
      timeSeriesChart.config.type = chartType;
      
      // Update dataset options
      timeSeriesChart.data.datasets[0].pointStyle = pointStyle;
      timeSeriesChart.data.datasets[0].pointRadius = pointSize;
      timeSeriesChart.data.datasets[0].borderWidth = lineThickness;
      timeSeriesChart.data.datasets[0].backgroundColor = pointColor;
      timeSeriesChart.data.datasets[0].borderColor = lineColor;
      
      // Special handling for line chart
      if (chartType === 'line') {
        timeSeriesChart.data.datasets[0].showLine = true;
        timeSeriesChart.data.datasets[0].tension = 0.1; // Slight curve for better visualization
        timeSeriesChart.data.datasets[0].fill = false;
      } else if (chartType === 'scatter') {
        timeSeriesChart.data.datasets[0].showLine = false;
      }
      
      // Update chart
      timeSeriesChart.update();
    });
    
    // Calculate appropriate Y-axis range for the data
    function calculateYAxisRange(data) {
      if (!data || data.length === 0) return { min: 0, max: 1 };
      
      // Find min and max values
      let minY = Infinity;
      let maxY = -Infinity;
      
      for (const point of data) {
        if (point.y < minY) minY = point.y;
        if (point.y > maxY) maxY = point.y;
      }
      
      // Add padding (15% on top and bottom)
      const range = maxY - minY;
      const padding = range * 0.15;
      
      // Ensure min doesn't go below zero for latency (unless data actually has negative values)
      const min = minY < 0 ? minY - padding : Math.max(0, minY - padding);
      const max = maxY + padding;
      
      console.log(`Data range - Min: ${minY.toExponential(4)}, Max: ${maxY.toExponential(4)}, Padded Range: ${min.toExponential(4)} to ${max.toExponential(4)}`);
      
      return { min, max };
    }
  </script>
</body>
</html>