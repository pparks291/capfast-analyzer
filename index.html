<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CapFast Latency Analyzer</title>
  <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f4f4f4;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    h1, h2, h3 {
      color: #333;
    }
    .chart-container {
      height: 400px;
      margin-top: 20px;
    }
    .file-section {
      margin-bottom: 20px;
      padding: 15px;
      background-color: #f8f8f8;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .button-group {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    .analysis-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .form-group {
      margin: 5px 0;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .tooltip {
      cursor: help;
      color: #4285f4;
      font-weight: bold;
      position: relative;
      display: inline-block;
    }
    .tooltip:hover::before {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 5px 10px;
      background-color: #333;
      color: white;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 12px;
      z-index: 1000;
    }
    .progress-section {
      margin: 15px 0;
      display: none;
    }
    .progress-bar {
      width: 100%;
      height: 20px;
      background-color: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-fill {
      height: 100%;
      background-color: #4CAF50;
      width: 0%;
      transition: width 0.3s;
    }
    .memory-bar {
      width: 100%;
      height: 12px;
      background-color: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }
    .memory-fill {
      height: 100%;
      background-color: #2196F3;
      width: 0%;
      transition: width 0.3s;
    }
    .memory-status {
      font-size: 14px;
      color: #555;
    }
    .results-section {
      margin-top: 20px;
      display: none;
    }
    button {
      padding: 8px 12px;
      background-color: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #3367d6;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    select, input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .file-info {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
    .log-messages {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 10px;
      padding: 10px;
      background-color: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    .log-message {
      margin: 2px 0;
      padding: 2px 0;
      border-bottom: 1px solid #eee;
    }
    .summary-stats {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background-color: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .stat-card h3 {
      margin-top: 0;
      color: #666;
      font-size: 14px;
    }
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #4285f4;
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 15px;
      cursor: pointer;
      background-color: #eee;
      margin-right: 5px;
      border-top-left-radius: 3px;
      border-top-right-radius: 3px;
    }
    .tab.active {
      background-color: white;
      border: 1px solid #ddd;
      border-bottom: none;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border: 1px solid #ddd;
    }
    th {
      background-color: #f2f2f2;
    }
    .action-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .chart-options {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
    .chart-options .form-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>CapFast Latency Analyzer</h1>
    
    <div class="file-section">
      <h2>Select Capture File</h2>
      <div class="button-group">
        <button id="select-file-btn">Select Capture File</button>
        <button id="load-analysis-btn">Load Previous Analysis</button>
      </div>
      <div id="file-path" class="file-info">No file selected</div>
      <div id="file-details" class="file-info"></div>
      <button id="analyze-btn" disabled>Analyze File</button>
    </div>
    
    <div id="progress-section" class="progress-section">
      <h2>Analysis Progress</h2>
      <div class="progress-bar">
        <div id="progress-fill" class="progress-fill"></div>
      </div>
      <div id="progress-text">0%</div>
      
      <div id="memory-status" class="memory-status" style="display: none; margin: 10px 0;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
          <span>Memory Usage:</span>
          <span id="memory-percentage">0%</span>
        </div>
        <div class="memory-bar">
          <div id="memory-fill" class="memory-fill"></div>
        </div>
        <div id="memory-tips" style="margin-top: 5px; font-size: 12px; color: #666; display: none;">
          <strong>Memory optimization tips:</strong>
          <ul style="margin: 5px 0; padding-left: 20px;">
            <li>Close other applications to free system memory</li>
            <li>Analyze fewer signals to reduce memory requirements</li>
            <li>Process smaller files first to optimize workflow</li>
          </ul>
        </div>
      </div>
      
      <div class="log-messages" id="log-messages"></div>
    </div>
    
    <div id="results-section" class="results-section">
      <h2>Analysis Results</h2>
      
      <div class="summary-stats" id="summary-stats">
        <!-- Summary statistics will be inserted here -->
      </div>
      
      <div class="form-group">
        <label for="signal-select">Select Signal: </label>
        <select id="signal-select"></select>
      </div>
      
      <div class="tabs">
        <div class="tab active" data-tab="time-series">Time Series</div>
        <div class="tab" data-tab="distribution">Distribution</div>
        <div class="tab" data-tab="statistics">Statistics</div>
      </div>
      
      <div class="tab-content active" id="time-series-tab">
        <div class="chart-options">
          <div class="form-group">
            <label for="x-axis-format">X-Axis Time Format:</label>
            <select id="x-axis-format">
              <option value="seconds">Seconds</option>
              <option value="time-hawaii">Wall Clock (Hawaii Time)</option>
              <option value="time-utc">Wall Clock (UTC)</option>
              <option value="time-chile">Wall Clock (Chile Time)</option>
            </select>
            <span class="tooltip" title="Seconds: Time since start of capture. Wall Clock: Time of day in selected timezone.">ⓘ</span>
          </div>
          <div class="form-group">
            <label for="y-axis-scale">Y-Axis Scale:</label>
            <select id="y-axis-scale">
              <option value="ns">Nanoseconds</option>
              <option value="us">Microseconds</option>
              <option value="ms">Milliseconds</option>
            </select>
          </div>
          <div class="form-group">
            <button id="refresh-chart-btn">Refresh Chart</button>
            <button id="reset-zoom-btn">Reset Zoom</button>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="time-series-chart"></canvas>
        </div>
      </div>
      
      <div class="tab-content" id="distribution-tab">
        <div class="chart-options">
          <div class="form-group">
            <button id="reset-dist-zoom-btn">Reset Zoom</button>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="distribution-chart"></canvas>
        </div>
      </div>
      
      <div class="tab-content" id="statistics-tab">
        <table id="stats-table">
          <thead>
            <tr>
              <th>Metric</th>
              <th>Value</th>
            </tr>
          </thead>
          <tbody>
            <!-- Statistics will be inserted here -->
          </tbody>
        </table>
      </div>
      
      <div class="action-buttons">
        <button id="save-analysis-btn">Save Analysis Results</button>
      </div>
    </div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    
    // Set Hawaii timezone offset in hours
    const HAWAII_TIMEZONE_OFFSET = -10;
    
    // Ensure moment adapter is properly registered for Chart.js
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Initializing CapFast Latency Analyzer');
      
      // Check if moment adapter is available
      if (typeof Chart !== 'undefined' && Chart.register) {
        console.log('Chart.js is available');
      } else {
        console.error('Chart.js is not properly loaded');
      }
    });
    
    // DOM elements
    const selectFileBtn = document.getElementById('select-file-btn');
    const loadAnalysisBtn = document.getElementById('load-analysis-btn');
    const analyzeBtn = document.getElementById('analyze-btn');
    const saveAnalysisBtn = document.getElementById('save-analysis-btn');
    const filePathElement = document.getElementById('file-path');
    const fileDetailsElement = document.getElementById('file-details');
    const progressSection = document.getElementById('progress-section');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const logMessages = document.getElementById('log-messages');
    const resultsSection = document.getElementById('results-section');
    const summaryStatsContainer = document.getElementById('summary-stats');
    const signalSelect = document.getElementById('signal-select');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const memoryStatus = document.getElementById('memory-status');
    const memoryFill = document.getElementById('memory-fill');
    const memoryPercentage = document.getElementById('memory-percentage');
    
    // Global variables
    let selectedFilePath = null;
    let analysisResults = null;
    let timeSeriesChart = null;
    let distributionChart = null;
    
    // Handle file selection
    selectFileBtn.addEventListener('click', async () => {
      const filePath = await ipcRenderer.invoke('select-file');
      
      if (filePath) {
        selectedFilePath = filePath;
        filePathElement.textContent = filePath;
        
        // Get file stats
        const stats = await ipcRenderer.invoke('get-file-stats', filePath);
        if (stats) {
          fileDetailsElement.textContent = `Size: ${formatFileSize(stats.size)}`;
        }
        
        // Enable analyze button
        analyzeBtn.disabled = false;
      }
    });
    
    // Handle loading previous analysis
    loadAnalysisBtn.addEventListener('click', async () => {
      const filePath = await ipcRenderer.invoke('show-load-dialog');
      
      if (filePath) {
        resetUI();
        progressSection.style.display = 'block';
        addLogMessage(`Loading analysis from ${filePath}...`);
        
        try {
          analysisResults = await ipcRenderer.invoke('load-analysis', filePath);
          
          if (analysisResults.error) {
            addLogMessage(`Error: ${analysisResults.error}`);
          } else {
            // Update file info if available
            if (analysisResults._fileInfo) {
              filePathElement.textContent = analysisResults._fileInfo.path || 'Original file path not available';
              fileDetailsElement.textContent = `Size: ${formatFileSize(analysisResults._fileInfo.size || 0)}`;
              addLogMessage(`Analysis date: ${new Date(analysisResults._fileInfo.date).toLocaleString()}`);
            }
            
            // Display results
            displayResults(analysisResults);
            addLogMessage('Analysis loaded successfully');
          }
        } catch (error) {
          addLogMessage(`Error loading file: ${error.message}`);
        }
      }
    });
    
    // Handle analysis button click
    analyzeBtn.addEventListener('click', async () => {
      if (!selectedFilePath) return;
      
      // Reset UI
      resetUI();
      
      // Show progress section
      progressSection.style.display = 'block';
      
      // Log start message
      addLogMessage('Starting analysis...');
      
      try {
        // Start analysis
        analysisResults = await ipcRenderer.invoke('analyze-file', selectedFilePath);
        
        if (analysisResults.error) {
          addLogMessage(`Error: ${analysisResults.error}`);
          if (analysisResults.details) {
            addLogMessage(`Details: ${analysisResults.details}`);
          }
        } else {
          // Display results
          displayResults(analysisResults);
        }
      } catch (error) {
        addLogMessage(`Error: ${error.message}`);
      }
    });
    
    // Handle saving analysis
    saveAnalysisBtn.addEventListener('click', async () => {
      if (!analysisResults) {
        addLogMessage('No analysis results to save');
        return;
      }
      
      const savePath = await ipcRenderer.invoke('show-save-dialog');
      if (savePath) {
        addLogMessage(`Saving analysis to ${savePath}...`);
        
        try {
          const result = await ipcRenderer.invoke('save-analysis', analysisResults, savePath);
          
          if (result.success) {
            addLogMessage(`Analysis saved successfully to ${savePath}`);
          } else {
            addLogMessage(`Error saving analysis: ${result.error}`);
          }
        } catch (error) {
          addLogMessage(`Error saving file: ${error.message}`);
        }
      }
    });
    
    // Listen for analysis status updates
    ipcRenderer.on('analysis-status', (event, status) => {
      updateProgress(status);
    });
    
    // Handle tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Update active tab
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show selected tab content
        const tabId = tab.getAttribute('data-tab');
        tabContents.forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(tabId + '-tab').classList.add('active');
      });
    });
    
    // Handle signal selection change
    signalSelect.addEventListener('change', () => {
      updateCharts();
    });
    
    // Handle x-axis format change
    document.getElementById('x-axis-format').addEventListener('change', () => {
      updateCharts();
    });
    
    // Handle y-axis scale change
    document.getElementById('y-axis-scale').addEventListener('change', () => {
      updateCharts();
    });
    
    // Handle refresh chart button click
    document.getElementById('refresh-chart-btn').addEventListener('click', () => {
      console.log('Refreshing chart...');
      
      // Get current settings
      const selectedSignal = signalSelect.value;
      const xAxisFormat = document.getElementById('x-axis-format').value;
      const yAxisScale = document.getElementById('y-axis-scale').value;
      
      console.log(`Settings: signal=${selectedSignal}, xFormat=${xAxisFormat}, yScale=${yAxisScale}`);
      
      // Force destroy the chart first
      if (timeSeriesChart) {
        console.log('Destroying time series chart');
        timeSeriesChart.destroy();
        timeSeriesChart = null;
      }
      
      if (distributionChart) {
        console.log('Destroying distribution chart');
        distributionChart.destroy();
        distributionChart = null;
      }
      
      // Create a small delay to ensure DOM updates
      setTimeout(() => {
        console.log('Recreating charts after timeout');
        
        // Get the contexts fresh (in case they were affected by the destroy)
        const timeCtx = document.getElementById('time-series-chart').getContext('2d');
        const distCtx = document.getElementById('distribution-chart').getContext('2d');
        
        if (!timeCtx || !distCtx) {
          console.error('Failed to get chart contexts');
          return;
        }
        
        updateCharts();
      }, 100);
    });
    
    // Handle reset zoom button click
    document.getElementById('reset-zoom-btn').addEventListener('click', () => {
      console.log('Resetting zoom for time series chart');
      
      // Reset zoom on time series chart
      if (timeSeriesChart) {
        timeSeriesChart.resetZoom();
      }
    });
    
    // Handle reset zoom button click for distribution chart
    document.getElementById('reset-dist-zoom-btn').addEventListener('click', () => {
      console.log('Resetting zoom for distribution chart');
      
      // Reset zoom on distribution chart
      if (distributionChart) {
        distributionChart.resetZoom();
      }
    });
    
    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(1024));
      
      return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
    }
    
    // Reset UI for new analysis
    function resetUI() {
      // Clear log messages
      logMessages.innerHTML = '';
      
      // Reset progress bar
      progressFill.style.width = '0%';
      progressText.textContent = '0%';
      
      // Hide results section
      resultsSection.style.display = 'none';
      
      // Clear previous charts
      if (timeSeriesChart) {
        timeSeriesChart.destroy();
        timeSeriesChart = null;
      }
      
      if (distributionChart) {
        distributionChart.destroy();
        distributionChart = null;
      }
    }
    
    // Update progress bar and status
    function updateProgress(status) {
      // Update progress bar
      progressFill.style.width = `${status.progress}%`;
      progressText.textContent = `${status.progress}%`;
      
      // Add log message
      addLogMessage(status.message);
      
      // Add memory usage info if available
      if (status.memory) {
        addLogMessage(`Memory usage - Heap: ${status.memory.heap}, System: ${status.memory.system}`);
        
        // Show memory status bar
        memoryStatus.style.display = 'block';
        
        // Extract percentage value
        const heapPercent = parseFloat(status.memory.heap);
        memoryFill.style.width = `${heapPercent}%`;
        memoryPercentage.textContent = status.memory.heap;
        
        // Color based on usage
        if (heapPercent > 80) {
          memoryFill.style.backgroundColor = '#f44336'; // Red
          document.getElementById('memory-tips').style.display = 'block'; // Show memory tips
        } else if (heapPercent > 60) {
          memoryFill.style.backgroundColor = '#FF9800'; // Orange
          document.getElementById('memory-tips').style.display = 'block'; // Show memory tips
        } else {
          memoryFill.style.backgroundColor = '#2196F3'; // Blue
          document.getElementById('memory-tips').style.display = 'none'; // Hide memory tips
        }
      }
      
      // Show results when complete
      if (status.status === 'complete') {
        progressFill.style.backgroundColor = '#4CAF50'; // Green
      } else if (status.status === 'error') {
        progressFill.style.backgroundColor = '#f44336'; // Red
      } else if (status.status === 'memory-emergency') {
        // Show warning for emergency memory management
        progressFill.style.backgroundColor = '#FFC107'; // Amber/warning
        addLogMessage('⚠️ Memory management activated: Some data points were automatically reduced to prevent memory overflow');
        document.getElementById('memory-tips').style.display = 'block'; // Show memory tips
      }
    }
    
    // Add log message
    function addLogMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'log-message';
      messageElement.textContent = message;
      logMessages.appendChild(messageElement);
      logMessages.scrollTop = logMessages.scrollHeight;
    }
    
    // Display analysis results
    function displayResults(results) {
      // Show results section
      resultsSection.style.display = 'block';
      
      // Clear previous UI
      summaryStatsContainer.innerHTML = '';
      signalSelect.innerHTML = '';
      
      // Get signals and sort by average latency (exclude internal _fileInfo key)
      const signals = Object.keys(results)
        .filter(key => key !== '_fileInfo')
        .sort((a, b) => results[b].stats.avgLatency - results[a].stats.avgLatency);
      
      if (signals.length === 0) {
        addLogMessage('No signals found with sufficient data points.');
        return;
      }
      
      // Populate signal selector
      signals.forEach(signalId => {
        const option = document.createElement('option');
        option.value = signalId;
        option.textContent = `${signalId} (${results[signalId].stats.count} samples)`;
        signalSelect.appendChild(option);
      });
      
      // Calculate summary statistics
      const totalSignals = signals.length;
      const totalSamples = signals.reduce((sum, signal) => sum + results[signal].stats.count, 0);
      const overallAvgLatency = signals.reduce((sum, signal) => 
        sum + results[signal].stats.avgLatency, 0) / totalSignals;
      const maxLatency = Math.max(...signals.map(s => results[s].stats.maxLatency));
      
      // Add summary statistic cards
      const summaryStats = [
        { label: 'Total Signals', value: totalSignals },
        { label: 'Total Samples', value: totalSamples.toLocaleString() },
        { label: 'Avg Latency', value: overallAvgLatency.toFixed(2) + ' µs' },
        { label: 'Max Latency', value: maxLatency.toFixed(2) + ' µs' }
      ];
      
      summaryStats.forEach(stat => {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.innerHTML = `
          <h3>${stat.label}</h3>
          <div class="stat-value">${stat.value}</div>
        `;
        summaryStatsContainer.appendChild(card);
      });
      
      // Update charts with first signal
      updateCharts();
    }
    
    // Update charts based on selected signal
    function updateCharts() {
      if (!analysisResults) return;
      
      const selectedSignal = signalSelect.value;
      if (!selectedSignal) return;
      
      const signalData = analysisResults[selectedSignal];
      
      // Get time format and scale options
      const xAxisFormat = document.getElementById('x-axis-format').value;
      const yAxisScale = document.getElementById('y-axis-scale').value;
      
      // Update time series chart
      updateTimeSeriesChart(signalData, xAxisFormat, yAxisScale);
      
      // Update distribution chart
      updateDistributionChart(signalData, yAxisScale);
      
      // Update statistics table
      updateStatisticsTable(signalData, yAxisScale);
    }
    
    // Scale latency value based on selected scale
    function scaleLatency(latency, scale) {
      switch (scale) {
        case 'ns':
          return latency; // No scaling (already in ns)
        case 'us':
          return latency / 1000; // Convert ns to μs
        case 'ms':
          return latency / 1000000; // Convert ns to ms
        default:
          return latency;
      }
    }
    
    // Get y-axis label based on scale
    function getYAxisLabel(scale) {
      switch (scale) {
        case 'ns':
          return 'Latency (ns)';
        case 'us':
          return 'Latency (μs)';
        case 'ms':
          return 'Latency (ms)';
        default:
          return 'Latency';
      }
    }
    
    // Update time series chart with new data
    function updateTimeSeriesChart(signalData, xAxisFormat, yAxisScale) {
      const ctx = document.getElementById('time-series-chart').getContext('2d');
      
      // Destroy previous chart if it exists
      if (timeSeriesChart) {
        timeSeriesChart.destroy();
      }
      
      // Create different datasets based on xAxisFormat
      let datasets = [];
      let chartType = 'scatter';
      let xAxisType = 'linear';
      let xAxisLabel = 'Time (seconds)';
      
      console.log(`Total data points: ${signalData.sampleData.length}`);
      
      // Performance optimization for extremely large datasets
      let pointData;
      const MAX_RENDER_POINTS = 25000; // Maximum points to render initially
      
      if (signalData.sampleData.length > MAX_RENDER_POINTS) {
        console.log(`Dataset too large (${signalData.sampleData.length} points), using decimation for initial view`);
        const decimationFactor = Math.ceil(signalData.sampleData.length / MAX_RENDER_POINTS);
        pointData = [];
        
        // Use decimation to show a representative sample initially
        for (let i = 0; i < signalData.sampleData.length; i += decimationFactor) {
          const point = signalData.sampleData[i];
          if (xAxisFormat === 'seconds') {
            pointData.push({
              x: point.timestamp,
              y: scaleLatency(point.latency, yAxisScale)
            });
          } else {
            pointData.push({
              x: new Date(point.timestamp * 1000),
              y: scaleLatency(point.latency, yAxisScale)
            });
          }
        }
        
        addLogMessage(`Performance mode: Initially rendering ${pointData.length} of ${signalData.sampleData.length} points. Zoom in to see more detail.`);
        
      } else if (xAxisFormat === 'seconds') {
        // For seconds format, use raw timestamps on a linear scale
        pointData = signalData.sampleData.map(point => ({
          x: point.timestamp,
          y: scaleLatency(point.latency, yAxisScale)
        }));
        
      } else if (xAxisFormat.startsWith('time')) {
        // For wall clock, use date objects
        pointData = signalData.sampleData.map(point => {
          const date = new Date(point.timestamp * 1000);
          return {
            x: date,
            y: scaleLatency(point.latency, yAxisScale)
          };
        });
      }
      
      datasets = [{
        label: 'Latency',
        data: pointData,
        backgroundColor: 'rgba(66, 133, 244, 0.7)',
        borderColor: 'rgba(66, 133, 244, 1)',
        pointRadius: pointData.length > 5000 ? 1 : (pointData.length > 1000 ? 2 : 3),
        pointHoverRadius: 5,
        showLine: xAxisFormat.startsWith('time')
      }];
      
      if (xAxisFormat.startsWith('time')) {
        chartType = 'scatter';
        xAxisType = 'time';
        xAxisLabel = 'Time (' + xAxisFormat.replace('time-', '') + ')';
      }
      
      // Log chart info (limited)
      console.log(`Creating chart with format: ${xAxisFormat}, type: ${chartType}, axis: ${xAxisType}`);
      console.log(`Dataset has ${datasets[0]?.data?.length || 0} points`);
      
      // Create chart configuration
      const config = {
        type: chartType,
        data: {
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: pointData.length > 5000 ? 0 : 1000 // Disable animation for large datasets
          },
          elements: {
            point: {
              radius: pointData.length > 5000 ? 1 : (pointData.length > 1000 ? 2 : 3)
            }
          },
          scales: {
            x: {
              type: xAxisType,
              title: {
                display: true,
                text: xAxisLabel
              },
              adapters: {
                date: {
                  timezone: xAxisFormat === 'time-hawaii' ? 'UTC-10' : 
                           xAxisFormat === 'time-chile' ? 'UTC-4' : 
                           'UTC'
                }
              },
              time: xAxisType === 'time' ? {
                unit: 'minute',
                displayFormats: {
                  minute: 'HH:mm:ss'
                },
                tooltipFormat: 'HH:mm:ss'
              } : undefined
            },
            y: {
              title: {
                display: true,
                text: getYAxisLabel(yAxisScale)
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  const point = context.raw;
                  const yLabel = point.y.toFixed(2);
                  
                  if (xAxisFormat === 'time-hawaii') {
                    const localTimeStr = new Date(point.x).toLocaleTimeString('en-US', { 
                      hour12: false,
                      timeZone: 'Pacific/Honolulu'
                    });
                    return `Time: ${localTimeStr}, Latency: ${yLabel}`;
                  } else if (xAxisFormat === 'time-utc') {
                    const localTimeStr = new Date(point.x).toLocaleTimeString('en-US', { 
                      hour12: false,
                      timeZone: 'UTC'
                    });
                    return `Time: ${localTimeStr}, Latency: ${yLabel}`;
                  } else if (xAxisFormat === 'time-chile') {
                    const localTimeStr = new Date(point.x).toLocaleTimeString('en-US', { 
                      hour12: false,
                      timeZone: 'America/Santiago'
                    });
                    return `Time: ${localTimeStr}, Latency: ${yLabel}`;
                  } else {
                    return `Time: ${point.x.toFixed(3)}s, Latency: ${yLabel}`;
                  }
                }
              }
            },
            zoom: {
              pan: {
                enabled: true,
                mode: 'xy'
              },
              zoom: {
                wheel: {
                  enabled: true,
                },
                pinch: {
                  enabled: true
                },
                mode: 'xy',
                drag: {
                  enabled: true,
                  backgroundColor: 'rgba(66, 133, 244, 0.1)',
                  borderColor: 'rgba(66, 133, 244, 0.5)'
                },
                onZoom: function() {
                  // This will load more detailed data when zoomed in - using existing datasets
                  const chart = this.chart;
                  // Performance check
                  console.log('Zoom event detected');
                }
              }
            }
          }
        }
      };
      
      // Create new chart
      timeSeriesChart = new Chart(ctx, config);
    }
    
    // Update distribution chart with new data
    function updateDistributionChart(signalData, yAxisScale) {
      const ctx = document.getElementById('distribution-chart').getContext('2d');
      
      // Destroy previous chart if it exists
      if (distributionChart) {
        distributionChart.destroy();
      }
      
      // Extract histogram data
      const bins = signalData.histogram.bins.map(bin => scaleLatency(bin, yAxisScale));
      const counts = signalData.histogram.counts;
      
      // Create chart configuration
      const config = {
        type: 'bar',
        data: {
          labels: bins.map(bin => bin.toFixed(2)),
          datasets: [{
            label: 'Frequency',
            data: counts,
            backgroundColor: 'rgba(66, 133, 244, 0.7)',
            borderColor: 'rgba(66, 133, 244, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              title: {
                display: true,
                text: getYAxisLabel(yAxisScale)
              }
            },
            y: {
              title: {
                display: true,
                text: 'Frequency'
              }
            }
          },
          plugins: {
            zoom: {
              pan: {
                enabled: true,
                mode: 'xy'
              },
              zoom: {
                wheel: {
                  enabled: true,
                },
                pinch: {
                  enabled: true
                },
                mode: 'xy'
              }
            }
          }
        }
      };
      
      // Create new chart
      distributionChart = new Chart(ctx, config);
    }
    
    // Update statistics table
    function updateStatisticsTable(signalData, yAxisScale) {
      const statsTable = document.getElementById('stats-table').querySelector('tbody');
      statsTable.innerHTML = '';
      
      const stats = signalData.stats;
      const scale = document.getElementById('y-axis-scale').value;
      
      // Create rows for each statistic with scaled values
      const rows = [
        { name: 'Count', value: stats.count.toLocaleString() },
        { name: 'Average Latency', value: `${scaleLatency(stats.avgLatency, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Minimum Latency', value: `${scaleLatency(stats.minLatency, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Maximum Latency', value: `${scaleLatency(stats.maxLatency, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Standard Deviation', value: `${scaleLatency(stats.stdDev, scale).toFixed(2)} ${getUnitLabel(scale)}` },
        { name: 'Jitter', value: `${stats.jitter.toFixed(4)} seconds` }
      ];
      
      // Add rows to table
      rows.forEach(row => {
        const tr = document.createElement('tr');
        
        const nameTd = document.createElement('td');
        nameTd.textContent = row.name;
        tr.appendChild(nameTd);
        
        const valueTd = document.createElement('td');
        valueTd.textContent = row.value;
        tr.appendChild(valueTd);
        
        statsTable.appendChild(tr);
      });
    }
    
    // Get unit label for statistics
    function getUnitLabel(scale) {
      switch (scale) {
        case 'ns':
          return 'nanoseconds';
        case 'us':
          return 'microseconds';
        case 'ms':
          return 'milliseconds';
        default:
          return 'units';
      }
    }
  </script>
</body>
</html>