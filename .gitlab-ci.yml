stages:
  - build
  - release

variables:
  GIT_STRATEGY: clone
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  CONTAINER_BUILD_IMAGE: $CI_REGISTRY_IMAGE/builder:$CI_COMMIT_REF_SLUG
  CONTAINER_TEST_IMAGE: $CI_REGISTRY_IMAGE/test:$CI_COMMIT_REF_SLUG

cache:
  paths:
    - node_modules/

.docker-login: &docker-login
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

build:builder-image:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  <<: *docker-login
  script:
    - |
      # Build the builder image with all dependencies
      docker build -t $CONTAINER_BUILD_IMAGE -f- . <<EOF
      FROM electronuserland/builder:wine
      RUN apt-get update && apt-get install -y dpkg fakeroot wine mono-complete
      WORKDIR /builds
      COPY package*.json ./
      RUN npm install
      EOF
    - docker push $CONTAINER_BUILD_IMAGE
  rules:
    - changes:
        - package.json
        - package-lock.json
      when: always
    - when: manual

build:linux:
  stage: build
  image: $CONTAINER_BUILD_IMAGE
  script:
    - npm run build
    - npx electron-builder --linux AppImage --publish never
  artifacts:
    paths:
      - dist/**/*
    expire_in: 1 week
  only:
    - main
    - tags

build:windows:
  stage: build
  image: $CONTAINER_BUILD_IMAGE
  script:
    - npm run build
    - npx electron-builder --windows nsis --publish never
  artifacts:
    paths:
      - dist/**/*
    expire_in: 1 week
  only:
    - main
    - tags

sync-to-github:
  stage: build
  image: alpine:latest
  script:
    - apk add --no-cache git curl jq bash
    - git config --global user.email "gitlab-ci@example.com"
    - git config --global user.name "GitLab CI"
    - git remote add github "https://${GITHUB_TOKEN}@github.com/pparks291/capfast-analyzer.git" || git remote set-url github "https://${GITHUB_TOKEN}@github.com/pparks291/capfast-analyzer.git"
    - git fetch origin
    - |
      if [[ -n "$CI_COMMIT_TAG" ]]; then
        git push github $CI_COMMIT_TAG
        REF=$CI_COMMIT_TAG
      else
        git push github HEAD:main
        REF=main
      fi
    - |
      echo "Waiting for GitHub Actions workflow to start..."
      ATTEMPTS=0
      MAX_ATTEMPTS=24
      CURRENT_SHA=$(git rev-parse HEAD)
      echo "Looking for workflow triggered by commit: $CURRENT_SHA"
      
      while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
        WORKFLOWS=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/pparks291/capfast-analyzer/actions/runs?head_sha=${CURRENT_SHA}")
        
        if [ $? -ne 0 ]; then
          echo "Failed to fetch workflows"
          exit 1
        fi
        
        WORKFLOW_COUNT=$(echo "$WORKFLOWS" | jq -r '.total_count')
        if [ "$WORKFLOW_COUNT" = "0" ]; then
          ATTEMPTS=$((ATTEMPTS + 1))
          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "No workflows found for commit ${CURRENT_SHA} after ${MAX_ATTEMPTS} attempts"
            exit 1
          fi
          echo "Attempt $ATTEMPTS of $MAX_ATTEMPTS - waiting 5 seconds..."
          sleep 5
          continue
        fi
        
        WORKFLOW_ID=$(echo "$WORKFLOWS" | jq -r '.workflow_runs[0].id')
        if [ "$WORKFLOW_ID" != "null" ] && [ "$WORKFLOW_ID" != "" ]; then
          echo "Found workflow ID: $WORKFLOW_ID for commit ${CURRENT_SHA}"
          break
        fi
        
        ATTEMPTS=$((ATTEMPTS + 1))
        if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
          echo "Timeout waiting for GitHub Actions workflow to start"
          exit 1
        fi
        echo "Attempt $ATTEMPTS of $MAX_ATTEMPTS - waiting 5 seconds..."
        sleep 5
      done
      
      echo "Monitoring workflow progress..."
      MONITOR_ATTEMPTS=0
      MAX_MONITOR_ATTEMPTS=20  # 10 minutes maximum wait (20 * 30 seconds)
      
      while [ $MONITOR_ATTEMPTS -lt $MAX_MONITOR_ATTEMPTS ]; do
        WORKFLOW_DATA=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/pparks291/capfast-analyzer/actions/runs/${WORKFLOW_ID}")
        
        if [ $? -ne 0 ]; then
          echo "Failed to fetch workflow status"
          exit 1
        fi
        
        STATUS=$(echo "$WORKFLOW_DATA" | jq -r '.status')
        CONCLUSION=$(echo "$WORKFLOW_DATA" | jq -r '.conclusion')
        
        echo "Current status: $STATUS (conclusion: $CONCLUSION)"
        
        if [ "$STATUS" = "completed" ]; then
          if [ "$CONCLUSION" = "success" ]; then
            echo "GitHub Actions workflow completed successfully!"
            # Create a file to indicate macOS builds are ready
            touch .macos_builds_ready
            exit 0
          else
            echo "GitHub Actions workflow failed with conclusion: $CONCLUSION"
            exit 1
          fi
        elif [ "$STATUS" = "null" ] || [ "$STATUS" = "" ]; then
          echo "Invalid workflow status received"
          exit 1
        fi
        
        MONITOR_ATTEMPTS=$((MONITOR_ATTEMPTS + 1))
        if [ $MONITOR_ATTEMPTS -eq $MAX_MONITOR_ATTEMPTS ]; then
          echo "Timeout waiting for workflow to complete after 10 minutes"
          exit 1
        fi
        
        echo "Waiting 30 seconds before next check..."
        sleep 30
      done
  artifacts:
    paths:
      - .macos_builds_ready
    expire_in: 1 week
    when: on_success
  only:
    - main
    - tags

create_release:
  stage: release
  image: node:18
  needs:
    - job: build:linux
      artifacts: true
    - job: build:windows
      artifacts: true
    - job: sync-to-github
      artifacts: true
  script:
    - |
      # Verify macOS builds completed successfully
      if [ ! -f .macos_builds_ready ]; then
        echo "macOS builds were not successful"
        exit 1
      fi
    - apt-get update -y && apt-get install -y curl jq
    - |
      # Get version from package.json
      VERSION=$(node -e "console.log(require('./package.json').version)")
      echo "Creating release v${VERSION}..."
      
      # Create the release
      RELEASE_RESPONSE=$(curl --silent --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
        --data "name=v${VERSION}" \
        --data "tag_name=v${VERSION}" \
        --data "description=Release v${VERSION}" \
        --data "ref=${CI_COMMIT_SHA}" \
        --request POST "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/releases")
      
      # Check if release was created successfully
      if [ "$(echo "$RELEASE_RESPONSE" | jq -r '.tag_name')" != "v${VERSION}" ]; then
        echo "Failed to create release. Response:"
        echo "$RELEASE_RESPONSE" | jq '.'
        exit 1
      fi
      
      echo "Release v${VERSION} created successfully"
      
      # Upload each artifact
      find dist -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.zip" \) | while read file; do
        filename=$(basename "$file")
        echo "Uploading $filename to release v${VERSION}..."
        
        # Upload file
        UPLOAD_RESPONSE=$(curl --silent --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
          --upload-file "$file" \
          --request POST "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/uploads")
        
        # Check if upload was successful
        if [ "$(echo "$UPLOAD_RESPONSE" | jq -r '.url')" = "null" ]; then
          echo "Failed to upload $filename. Response:"
          echo "$UPLOAD_RESPONSE" | jq '.'
          continue
        fi
        
        # Get URL from response
        UPLOAD_URL=$(echo "$UPLOAD_RESPONSE" | jq -r ".url")
        
        # Add file to release
        LINK_RESPONSE=$(curl --silent --request POST \
          --header "PRIVATE-TOKEN: ${GITLAB_API_TOKEN}" \
          --data "name=${filename}" \
          --data "url=${UPLOAD_URL}" \
          "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/releases/v${VERSION}/assets/links")
        
        # Check if link was created successfully
        if [ "$(echo "$LINK_RESPONSE" | jq -r '.url')" = "null" ]; then
          echo "Failed to create link for $filename. Response:"
          echo "$LINK_RESPONSE" | jq '.'
          continue
        fi
        
        echo "Successfully uploaded and linked $filename"
      done
      
      echo "Release creation completed!"
  only:
    - main
    - tags 